// Translated from algs4 BTree.java
// https://github.com/kevin-wayne/algs4/blob/master/src/main/java/edu/princeton/cs/algs4/BTree.java

/*
Here is homework 5.
Homework 6 can add each lock for each node or entry similar to before.
*/

#include "thread_helper.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
// max children per B-tree node = M-1
// (must be even and greater than 2)
#define M 4
#define ONE_MILLION 1000000
/*
Too large may cause valgrind "Warning: set address range perms: large range"
https://web.stanford.edu/class/archive/cs/cs107/cs107.1176/guide_valgrind.html
*/
#define STRING_BLOCK 1024 // 2048 may be too large and will casue heap overflow...

#ifndef THREAD_NUM
#define THREAD_NUM 11
#endif

/*
sometimes
maybe output
"""
(www.amazon.com)
     (www.amazon.com)
          (www.amazon.com)
               (www.amazon.com)
                    (www.amazon.com)
                         www.amazon.com 128.112.136.12
                         www.amazon.com 128.112.136.12
                    (www.amazon.com)
                         www.amazon.com 128.112.136.12
                         www.amazon.com 128.112.136.12
               (www.amazon.com)
                    (www.amazon.com)
                         www.amazon.com 128.112.136.12
                         www.amazon.com 128.112.136.12
                    (www.amazon.com)
                         www.amazon.com 128.112.136.12
                         www.amazon.com 128.112.136.12
                    (www.amazon.com)
                         www.amazon.com 128.112.136.12
                         www.apple.com 128.112.136.12
          (www.apple.com)
"""
this is due to the write order.
*/
#ifndef DEBUG_APPLE_IN_AMAZON
#define DEBUG_APPLE_IN_AMAZON 0
#endif

/*
http://www.btechsmartclass.com/data_structures/tree-terminology.html
https://en.wikipedia.org/wiki/B-tree#Definition
1. internal nodes has children (non-leaf) excluding the root. 
2. Think it as one multi-level page table, where the parent table 
store the next page table base address (i.e. next)
and only the bottom level page table has many `val`s
3. one example tree generated by here (only show "key"s)
root -> {"aaa","bbb"}
"aaa" -> {"aaa","aab"}
"bbb" -> {"bbb","bbc"}

4. more detailed btree architecture See "toStringHelper"
"""
(www.amazon.com)
     (www.amazon.com)
          (www.amazon.com)
               (www.amazon.com)
                    (www.amazon.com)
                         www.amazon.com 128.112.136.12
                         www.amazon.com 128.112.136.12
                    (www.amazon.com)
                         www.amazon.com 128.112.136.12
                         www.amazon.com 128.112.136.12
               (www.amazon.com)
                    (www.amazon.com)
                         www.amazon.com 128.112.136.12
                         www.amazon.com 128.112.136.12
                    (www.amazon.com)
                         www.amazon.com 128.112.136.12
                         www.amazon.com 128.112.136.12
                    (www.amazon.com)
                         www.amazon.com 128.112.136.12
                         www.apple.com 128.112.136.12
"""
a. here the root key "(www.amazon.com)" is changed by "mod_parent"
b. "www.apple.com" in "www.amazon.com", View "./btree_debug_apple_in_amazon.out"
c. "(www.amazon.com)" created by something like `initEntry(btree->root->children[0]->key, NULL, btree->root)`
has `next` variable which points to the next node
*/
// internal nodes: only use key and next
// external nodes: only use key and value
typedef struct __entry_t {
  char *key;
  char *val;
  struct __node_t *next; // helper field to iterate over array entries
} entry_t;

// helper B-tree node data type
typedef struct __node_t {
  int m;                // number of children
  char pad[sizeof(entry_t *) - sizeof(int)];
  entry_t *children[M]; // the array of children
} node_t;

/*
here height is 0 at init,
and the height is the tree/subtree's height.
notice here tree is only one (so only one lock each tree) and the subtree is created in mind but not in the program 
(it is controlled by the height and 0 means the leaf node).
*/
typedef struct __btree_t {
  node_t *root; // root of the B-tree
  int height;   // height of the B-tree
  int n;        // number of key-value pairs in the B-tree
  pthread_mutex_t lock;
} btree_t;

typedef struct __myarg_t {
  btree_t *btree;
  int threads;
  char pad[sizeof(btree_t *) - sizeof(int)];
} myarg_t;

/*
Notice the `initNode` mallocs M entries always, so take care when free.
*/

static entry_t *initEntry(char *key, char *val, node_t *next) {
  entry_t *new = malloc(sizeof(entry_t));
  if (new == NULL)
    handle_error_en(errno, "malloc");
  new->key = key;
  new->val = val;
  new->next = next;
  return new;
}

static node_t *initNode(int m) {
  node_t *new = malloc(sizeof(node_t));
  if (new == NULL)
    handle_error_en(errno, "malloc");
  new->m = m;
  /*
  when m not equals M, it is difficult to manage the dynamic memory.
  */
  for (size_t i = 0; i < M; i++)
    new->children[i] = initEntry("", "", NULL);
  return new;
}

static btree_t *initBtree() {
  btree_t *new = malloc(sizeof(btree_t));
  if (new == NULL)
    handle_error_en(errno, "malloc");
  new->height = 0;
  new->n = 0;
  new->root = initNode(0);
  Pthread_mutex_init(&new->lock, NULL);
  return new;
}

/*
1. set mod_parent (`ret->mod_parent =1;`) when it is less than all leaf children 
and update the parent key recursively (`h->children[j-1]->key = key;`).
2. `ret_node` is what returned by `static node_t *insert` in the original code.
*/

typedef struct __insert_ret{
  node_t * ret_node;
  int mod_parent;
} insert_ret;

static insert_ret *insert(node_t *h, char *key, char *val, int ht);
static node_t *split(node_t *h);
static char *toStringHelper(node_t *h, int ht, char *indent);

// Returns the value associated with the given key.
// static char *get(btree_t *btree, char *key) {
//   if (key == NULL)
//     return NULL;

//   return search(btree->root, key, btree->height);
// }
#if DEBUG_APPLE_IN_AMAZON
static char *search(node_t *x, char *key, int ht);
static char *search(node_t *x, char *key, int ht) {
  entry_t *children[M];
  for (size_t i = 0; i < M; i++)
    children[i] = x->children[i];

  // external node, i.e. leaf
  if (ht == 0) {
    for (int j = 0; j < x->m; j++) {
      if (key == children[j]->key)
        return children[j]->val;
    }
  }

  // internal node
  else {
    for (int j = 0; j < x->m; j++) {
      /*
      1. based on balance, the order is the increasing value with the increasing index.
      2. `j + 1 == x->m` means the `key` must be larger than 
      the largest child index key `children[j + 1]->key`
      So try searching in the last subtree. 
      */
      if (j + 1 == x->m || strcmp(key, children[j + 1]->key) < 0)
        return search(children[j]->next, key, ht - 1);
    }
  }
  return NULL;
}
#endif

// Returns a string representation of this B-tree (for debugging).
static char *toString(btree_t *btree) {
  return toStringHelper(btree->root, btree->height, "");
}

static char *toStringHelper(node_t *h, int ht, char *indent) {
  char *s = calloc(STRING_BLOCK * sizeof(char),STRING_BLOCK);
  if (!s) {
    // handle_error_en(errno, "malloc s");
    // fflush(stdout);
  }
  entry_t *children[M];
  for (size_t i = 0; i < M; i++) {
    children[i] = h->children[i];
  }
  /*
  output root->children[0]
  */
  // if (!strcmp(indent, "")) {
  //   strcat(s, indent);
  //   strcat(s, "(");
  //   strcat(s, children[0]->key);
  //   strcat(s, ")\n");
  // }

  if (ht == 0) {
    for (int j = 0; j < h->m; j++) {
      strcat(s, indent);
      strcat(s, children[j]->key);
      strcat(s, " ");
      if (children[j]->val == NULL) {
        strcat(s, "null");
      } else {
        strcat(s, children[j]->val);
      }
      strcat(s, "\n");
    }
  } else {
    for (int j = 0; j < h->m; j++) {
      strcat(s, indent);
      strcat(s, "(");
      strcat(s, children[j]->key);
      strcat(s, ")\n");
      char *intentCp = malloc(STRING_BLOCK * sizeof(char));
      if (!intentCp) {
        handle_error_en(errno, "malloc intentCp");
      }
      strcpy(intentCp, indent);
      strcat(intentCp, "     ");
      char * subtree_str = toStringHelper(children[j]->next, ht - 1, intentCp);
      strcat(s, subtree_str);
      /*
      Notice if not free btree at each iteration, `free(intentCp);` may cause weird errors.
      like `munmap_chunk()` although the `intentCp` is in heap but maybe weirdly changed 
      so that it is not associated with `malloc`. See https://stackoverflow.com/a/32118638/21294350
      */
      free(intentCp);
      free(subtree_str);
    }
  }
  return s;
}

/**
 * Inserts the key-value pair into the symbol table, overwriting the old value
 * with the new value if the key is already in the symbol table.
 * If the value is null, this effectively deletes the key from the symbol table.
 */
static void put(btree_t *btree, char *key, char *val) {
  if (key == NULL)
    return;
  #if DEBUG_APPLE_IN_AMAZON
  char* search_val;
  if (!strcmp(key, "www.apple.com") && (search_val = search(btree->root, key, btree->height))!=NULL) {
    printf("find %s: %s\n",key,search_val);
    char *btree_structure = toString(btree);
    printf("%s\n", btree_structure);
    free(btree_structure);
  }
  #endif
  insert_ret *u = insert(btree->root, key, val, btree->height);
  btree->n++;
  if (u->mod_parent) {
    btree->root->children[0]->key = key;
  }
  if (u->ret_node == NULL){
    /*
    why valgrind still has
    """
    ==45538== 944 bytes in 59 blocks are definitely lost in loss record 5 of 26 
    ==45538==    at 0x484178B: malloc (vg_replace_malloc.c:431)       
    ==45538==    by 0x109A27: insert (btree.c:280)                                            
    ==45538==    by 0x109B8A: insert (btree.c:318)                                            
    ==45538==    by 0x109B8A: insert (btree.c:318)                    
    ==45538==    by 0x109B8A: insert (btree.c:318)                                            
    ==45538==    by 0x109B8A: insert (btree.c:318)                                            
    ==45538==    by 0x10991E: put (btree.c:252)                                               
    ==45538==    by 0x109655: thread_function (btree.c:380)    
    ==45538==    by 0x49499EA: start_thread (pthread_create.c:444)                            
    ==45538==    by 0x49CDC83: clone (clone.S:100)   
    """
    after free between each return and the u allocation here.

    fixed: view the all return of the function to ensure free of unused dynamic allocated local variables.
    */
    free(u);
    return;
  }

  // need to split root
  node_t *t = initNode(2);
  /*
  1. Here t->children[0] not stores `val` but let t->children[0]->children[0] store the data 
  which is originally root->children[0]->val.
  2. t->children[1] stores `u->children[0]->key` because `t->children[j] = h->children[M / 2 + j];` stores
  the right half of original root.
  3. here
  old_root -> {1,2,3,4}
  will be 
  new_root -> {1(old_root):{1,2},3:{3,4}} 
  (here original {3,4} in old_root is freed/invalidated by `h->children[M / 2 + j] = NULL;`.)
  (above is one simplified representation where only keys are shown)
  4. here `free(t->children[0])` is ok because it free the address stored in t->children[0]
  instead of `t->children[0]` self.
  */
  entry_t * old_entry = t->children[0];
  t->children[0] = initEntry(btree->root->children[0]->key, NULL, btree->root);
  free(old_entry);
  old_entry = t->children[1];
  t->children[1] = initEntry(u->ret_node->children[0]->key, NULL, u->ret_node);
  free(old_entry);
  free(u);
  btree->root = t;
  btree->height++;
  return;
}

static insert_ret *insert(node_t *h, char *key, char *val, int ht) {
  int j=0;
  insert_ret* ret = malloc(sizeof(insert_ret));
  ret->mod_parent=0;
  ret->ret_node=NULL;
  entry_t *t = initEntry(key, val, NULL);
  int reach_end = 0;

  // external node
  if (ht == 0) {
    /*
    1. Notice if here `key < h->children[0]->key` and not split, then it will insert at the start of the last level.
    but after returning to the up level, it won't change the parent key
    so maybe child key is bigger than the parent 
    2. "" always less than strings So ignore it to avoid recursion.
    3. break after `h->m==0` to ensure unnecessary assignment of later `j=1`.
    then `for (int i = h->m; i > j; i--)` can insert value.
    i.e. h->m=0 -> j=0 -> `h->children[j] = t;`
    h->m=1 -> insert_node -> whether `h->children[i] = h->children[i - 1];` depends on whether `ret->mod_parent`
    h->m>1 just functions as before.
    */
    if (h->m==0) {
      goto insert_node;
    }
    if (strcmp(key, "") !=0 && strcmp(key, h->children[0]->key) < 0){
      ret->mod_parent =1;
      goto insert_node;
    }
    for (j = 1; j < h->m; j++) {
      if (strcmp(key, h->children[j]->key) < 0)
        break;
    }
  }

  // internal node
  else {
    for (j = 0; j < h->m; j++) {
      /*
      select the correct subtree to insert
      and the real insert is done when ht=0.
      then recursively check split and pass the mod_parent added by myself.
      */
      if ((reach_end=(j + 1 == h->m)) || strcmp(key, h->children[j + 1]->key) < 0) {
        /*
        1. Go into the subtree so `ht - 1`
        */
        #if DEBUG_APPLE_IN_AMAZON
        if (strcmp(key, "www.apple.com")==0) {
          if (!reach_end)
            printf("%s < %s and insert to %s\n",key,h->children[j + 1]->key,h->children[j]->key);
          else
            printf("%s > all children and insert after %s\n",key,h->children[j]->key);
          fflush(stdout);
        }
        #endif
        insert_ret *u = insert(h->children[j++]->next, key, val, ht - 1);
        if (u->mod_parent) {
          h->children[j-1]->key = key;
        }
        if (u->ret_node == NULL){
          /*
          check return in this function to 
          ensure all non-return dynamic allocated local variables are all freed.
          */
          free(ret);
          free(t);
          return u;
        }
        /*
        prepare for the following insert at h level 
        because one `h` children sub-tree is splitted and a new node is created.
        */
        t->key = u->ret_node->children[0]->key;
        t->next = u->ret_node;
        free(u);
        break;
      }
    }
  }
  /*
  1. If in the internal node, `split` occurs at the `ht=0`
  then when ht=1, `h->children[j++]->next` has been cut half when returning from `insert(h->children[j++]->next, key, val, ht - 1)`.
  but when ht=1, `h->m` keeps unchanged.
  So `for (int i = h->m; i > j; i--)...` put the split generated `t` after the splitted location 
  which is implied by above `[j++]`.
  */

  /*
  Here `h->m < M` always holds,
  */
  // entry_t* old_entry = h->children[h->m];
  /*
  Notice here `free` needs be after `insert_node:` to take the special case "goto insert_node;" in account.
  */
  insert_node: free(h->children[h->m]);
  for (int i = h->m; i > j; i--)
    h->children[i] = h->children[i - 1];
  h->children[j] = t;
  h->m++;
  if (h->m < M){
    ret->ret_node=NULL;
    return ret;
  }
  else{
    ret->ret_node=split(h);
    return ret;
  }
}

// split node in half
static node_t *split(node_t *h) {
  node_t *t = initNode(M / 2);
  entry_t * old_entry;
  h->m = M / 2;
  for (int j = 0; j < M / 2; j++){
    old_entry = t->children[j];
    t->children[j] = h->children[M / 2 + j];
    free(old_entry);
    h->children[M / 2 + j] = NULL; /* To avoid duplicate free or by use h->m control free range*/
  }
  return t;
}


static void *thread_function(void *args) {
  myarg_t *m = (myarg_t *)args;
  char *urls[] = {"www.cs.princeton.edu", "www.princeton.edu", "www.yale.edu",
                  "www.simpsons.com",     "www.apple.com",     "www.amazon.com",
                  "www.ebay.com",         "www.cnn.com",       "www.google.com",
                  "www.nytimes.com",      "www.microsoft.com"};
  Pthread_mutex_lock(&m->btree->lock);
  /*
  let each thread do the same thing.
  */
  for (int i = 0; i < 100 / m->threads; i++)
    put(m->btree, urls[i % 11], "128.112.136.12");
  Pthread_mutex_unlock(&m->btree->lock);
  pthread_exit(EXIT_SUCCESS);
}

void free_node (node_t* subnode){
  /*
  recommend use `i<M` to free all `initEntry` allocated memory.
  */
  for (int i=0; i<M; i++) {
    /*
    Here `initNode(0);` calls `initEntry` 4 times So maybe causes memory leak if using root->m.
    */
    if (subnode->children[i]==NULL) {
      continue;
    }
    /*
    1. Here first recursively free the relative leaf nodes and then the relative parent.
    2. in loop, not free something is independent from `i` which will probably cause double free.
    */
    node_t* target_node = subnode->children[i]->next;
    if (target_node!=NULL) {
      free_node(target_node);
    }
    free(subnode->children[i]);
  }
  free(subnode);
  return;
}

// Unit tests the BTree data type.
int main(int argc, char *argv[]) {
  for (int i = 1; i <= THREAD_NUM; i++) {
    btree_t *btree = initBtree();
    int s = 0;
    myarg_t args;
    args.btree = btree;
    args.threads = i;
    pthread_t *threads = malloc((size_t)i * sizeof(pthread_t));
    if (threads == NULL)
      handle_error_en(errno, "malloc");
    struct timeval start, end;
    s = gettimeofday(&start, NULL);
    if (s != 0)
      handle_error_en(s, "gettimeofday");
    for (int j = 0; j < i; j++)
      pthread_create(&threads[j], NULL, &thread_function, &args);
    for (int k = 0; k < i; k++)
      pthread_join(threads[k], NULL);
    s = gettimeofday(&end, NULL);
    if (s != 0)
      handle_error_en(s, "gettimeofday");
    long long startusec, endusec;
    startusec = start.tv_sec * ONE_MILLION + start.tv_usec;
    endusec = end.tv_sec * ONE_MILLION + end.tv_usec;
    printf("%d threads\n", i);
    printf("Time (seconds): %f\n\n",
           ((double)(endusec - startusec) / ONE_MILLION));
    printf("size: %d\n\n", btree->n);
    char *btree_structure = toString(btree);
    printf("%s\n", btree_structure);
    free(btree_structure);
    free(threads);
    // for (int i=0; i<M; i++) {
    //   free_node(btree->root->children[i]->next);
    // }
    /*
    TODO weird why always miss one entry with the root node each iteration
    """
     73 ==50038== 24 bytes in 1 blocks are definitely lost in loss record 3 of 9
     74 ==50038==    at 0x484178B: malloc (vg_replace_malloc.c:431)
     75 ==50038==    by 0x10987D: initEntry (btree.c:99)
     76 ==50038==    by 0x109831: initNode (btree.c:117)
     77 ==50038==    by 0x10975C: initBtree (btree.c:127)
     78 ==50038==    by 0x10933B: main (btree.c:450)
    """

    fixed: See above "free(h->children[h->m]);"
    */
    free_node(btree->root);
    free(btree);
  }

  // put(btree, "www.cs.princeton.edu", "128.112.136.12");
  // put(btree, "www.cs.princeton.edu", "128.112.136.11");
  // put(btree, "www.cs.princeton.edu", NULL);
  // put(btree, "www.princeton.edu",    "128.112.128.15");
  // put(btree, "www.yale.edu",         "130.132.143.21");
  // put(btree, "www.simpsons.com",     "209.052.165.60");
  // put(btree, "www.apple.com",        "17.112.152.32");
  // put(btree, "www.amazon.com",       "207.171.182.16");
  // put(btree, "www.ebay.com",         "66.135.192.87");
  // put(btree, "www.cnn.com",          "64.236.16.20");
  // put(btree, "www.google.com",       "216.239.41.99");
  // put(btree, "www.nytimes.com",      "199.239.136.200");
  // put(btree, "www.microsoft.com",    "207.126.99.140");
  // put(btree, "www.dell.com",         "143.166.224.230");
  // put(btree, "www.slashdot.org",     "66.35.250.151");
  // put(btree, "www.espn.com",         "199.181.135.201");
  // put(btree, "www.weather.com",      "63.111.66.11");
  // put(btree, "www.yahoo.com",        "216.109.118.65");

  // printf("cs.princeton.edu:  %s\n", get(btree, "www.cs.princeton.edu"));
  // printf("hardvardsucks.com: %s\n", get(btree, "www.harvardsucks.com"));
  // printf("simpsons.com:      %s\n", get(btree, "www.simpsons.com"));
  // printf("apple.com:         %s\n", get(btree, "www.apple.com"));
  // printf("ebay.com:          %s\n", get(btree, "www.ebay.com"));
  // printf("dell.com:          %s\n", get(btree, "www.dell.com"));

  // printf("size:      %d\n", btree->n);
  // printf("height:    %d\n", btree->height);
  return 0;
}
